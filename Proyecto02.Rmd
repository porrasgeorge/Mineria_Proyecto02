---
title: "Proyecto 02"
author: "Jorge Porras & Alex Cruz"
date: "12/4/2020"
output: html_document
---

# ¿Es posible predecir desbalances de tension?

#### Carga de librerias

```{r}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(RODBC)
library(lubridate)
library(feather)
library(ggplot2)
library(tidyr)
library(caTools)
library(randomForest)
#library(xlsx)
```

#### Rango de fechas (lubridate)

```{r}
end_dateCR <- floor_date(now(), "week")  ## primer domingo hacia atras
start_dateCR <- end_dateCR - weeks(8)+ days(1) ## 8 semanas atras (lunes)
```

#### Fecha-hora a UTC (lubridate) (DB está en UTC)

```{r}
initial_date <- with_tz(start_dateCR, tzone = "UTC") 
final_date <- with_tz(end_dateCR, tzone = "UTC") 
```

#### Valores Nominales (vectores)

```{r}
nom_voltage <- 24900
cut_voltage <- 25100
tensiones <- c("Nom" = nom_voltage, 
               "limit087" = 0.87*nom_voltage,
               "limit091" = 0.91*nom_voltage,
               "limit093" = 0.93*nom_voltage,
               "limit095" = 0.95*nom_voltage,
               "limit105" = 1.05*nom_voltage,
               "limit107" = 1.07*nom_voltage,
               "limit109" = 1.09*nom_voltage,
               "limit113" = 1.13*nom_voltage)

```

#### Conexion a SQL Server y carga de tablas (RODBC)

```{r eval = FALSE}
channel <- odbcConnect("SQL_ION", uid="sa", pwd="xxxxxx")
sources <- sqlQuery(channel , "select top 100 ID, Name, DisplayName from Source where Name like 'Coopeguanacaste.%'")
sources$Name <- gsub("Coopeguanacaste.", '', sources$Name)
sources <- sources %>% filter(ID %in% c(57))

quantity <- sqlQuery(channel , "select top 1500000 ID, Name from Quantity where Name like 'Voltage%'")
quantity <- quantity %>% filter(grepl("^Voltage Phases [ABC][ABC] Mean$", Name))
quantity$Name <- c('Vab', 'Vbc', 'Vca')

sources_ids <- paste0(sources$ID, collapse = ",")
quantity_ids <- paste0(quantity$ID, collapse = ",")
dataLog <- sqlQuery(channel , paste0("select top 500000 * from dataLog2 where ",
                                      "SourceID in (", sources_ids, ")",
                                      " and QuantityID in (", quantity_ids, ")",
                                      " and TimestampUTC >= '", initial_date, "'",
                                      " and TimestampUTC < '", final_date, "'"))

odbcCloseAll()

```

#### Guardar archivos con las tablas

```{r eval = FALSE}
#write_feather(dataLog, "featherFiles/dataLog.feather")
#write_feather(quantity, "featherFiles/quantity.feather")
#write_feather(sources, "featherFiles/sources.feather")
```

#### Leer Archivos de las tablas
```{r}
#rm(dataLog, quantity, sources)
dataLog <- read_feather("featherFiles/dataLog.feather")
quantity <- read_feather("featherFiles/quantity.feather")
sources <- read_feather("featherFiles/sources.feather")
```


### Contenido de las tablas

#### Datalog

```{r}
glimpse(dataLog)
```

#### Quantity

```{r}
glimpse(quantity)
```

#### Sources

```{r}
glimpse(sources)
```



#### Transformacion de datos para analisis previo
```{r}
## Transformacion de columnas
dataLog$TimestampUTC <- as_datetime(dataLog$TimestampUTC)
dataLog$TimestampCR <- with_tz(dataLog$TimestampUTC, tzone = "America/Costa_Rica") 
dataLog$TimestampUTC <- NULL
dataLog$ID <- NULL
dataLog$year <- year(dataLog$TimestampCR)
dataLog$month <- month(dataLog$TimestampCR)
dataLog$day <- day(dataLog$TimestampCR)
dataLog$hour <- hour(dataLog$TimestampCR)
dataLog$wday <- wday(dataLog$TimestampCR)
dataLog$wdayName <- weekdays(dataLog$TimestampCR)
dataLog$hour2 <- hour(dataLog$TimestampCR)+ (minute(dataLog$TimestampCR)/60)

```


#### Union de tablas, borrado de columnas no importantes y Categorizacion de valores
```{r}
dataLog <- dataLog %>% left_join(quantity, by = c('QuantityID' = "ID")) %>%
  left_join(sources, by = c('SourceID' = "ID"))

names(dataLog)[names(dataLog) == "Name.x"] <- "Quantity"
names(dataLog)[names(dataLog) == "Name.y"] <- "Meter"

dataLog$SourceID <- NULL
dataLog$QuantityID <- NULL
dataLog$DisplayName <- NULL
#rm(quantity, sources)
```
#### Contenido de la tabla Datalog

```{r}
glimpse(dataLog)
```

## Análisis de datos
### Histogramas y boxplots

#### Cantidad de filas inicial

```{r}
initial_rows <- nrow(dataLog)
initial_rows
```


#### Boxplot del comportamiento de la tension (horizontal)

```{r}
boxplot(dataLog$Value, xlab= "Voltaje", col="Orange", border = "brown", horizontal = T, main = "Voltaje Promedio") 
```


#### Histograma inicial

```{r}
hist(dataLog$Value, col="Orange", border = "brown", xlab = "Valor", ylab = "Frecuencia", main = "Histograma de Tension")

```


#### Variable temporal solo para análisis (originalmente se tenian 15825 rows)

```{r}
dl_temp <- dataLog %>% filter(Value > 25100)
### Cantidad de filas
final_rows <- nrow(dl_temp)
print(paste0 ("Se eliminaron el ", round(100*((initial_rows - final_rows)/initial_rows), 2), "% de las filas" ))
```

#### Boxplot con un filtro temporal de los datos (para análisis unicamente)

```{r}
boxplot(dl_temp$Value, xlab= "Voltaje", col="Orange", border = "brown", horizontal = T, main = "Voltaje Promedio") 
```

#### Histograma eliminando outliers de la tabla temporal

```{r}
hist(dl_temp$Value, col="Orange", border = "brown", xlab = "Tension", ylab = "Frecuencia", breaks = 60, main = "Histograma de Tension")
```

#### Grafico de densidad
```{r}
d <- density(dl_temp$Value)
plot(d, main = "Densidad")
polygon(d, col = "Orange", border = "brown")
```

#### Boxplot separado por variable

```{r}

bp <- ggplot(dl_temp, aes(Quantity, Value))
bp <- bp + geom_boxplot(aes(colour = Quantity))
bp <- bp + scale_color_brewer(palette="Dark2")
bp

```


#### Grafico de densidad para cada variable

```{r}
lineas <- dl_temp %>% group_by(Quantity) %>% summarise(v = mean(Value))

p <- ggplot(dl_temp, aes(x=Value, fill = Quantity)) + 
  geom_density(alpha = 0.6) +
  geom_vline(data=lineas, aes(xintercept=v, color=Quantity), size = 2)
p
```


### Aqui inician la modificaciones reales de los datos

#### Pivot para generar columnas para las 3 variables de tension y eliminar los outliers

```{r}

dataLog2 <- tidyr::spread(dataLog, Quantity, Value)
dataLog2 <- dataLog2 %>% filter(Vab > cut_voltage, Vbc>cut_voltage, Vca > cut_voltage)
```

#### Muesta de la tabla

```{r}
head(dataLog2, 15)
```


### Cálculo del procentaje de desbalance

```{r}
unbal_calc  <- function(va, vb, vc){
  maximo =  pmax(abs(va-vb), abs(vb-vc), abs(vc-va))
  promedio = (va + vb + vc)/3
  return(100*maximo/promedio)
} 

dataLog2 <- dataLog2 %>% mutate (unbalance = unbal_calc(Vab, Vbc, Vca))

```




```{r}
a <- dataLog2 %>% group_by(hour2) %>% summarise(v = mean(unbalance))
ggplot(a, aes(hour2, v)) + geom_point() + geom_line(col = "orange")

a <- dataLog2 %>% group_by(wdayName, hour2) %>% summarise(v = mean(unbalance))
ggplot(a, aes(hour2, v)) + geom_line(aes(colour = factor(wdayName)))

```























##Clasificacion de datos
```{r eval = FALSE}
dataLog <- dataLog %>% mutate(classif = case_when(Value < tensiones["limit087"] ~ "TN087",
                                                  Value < tensiones["limit091"] ~ "TN087_091",
                                                  Value < tensiones["limit093"] ~ "TN091_093",
                                                  Value < tensiones["limit095"] ~ "TN093_095",
                                                  Value < tensiones["limit105"] ~ "TN095_105",
                                                  Value < tensiones["limit107"] ~ "TN105_107",
                                                  Value < tensiones["limit109"] ~ "TN107_109",
                                                  Value < tensiones["limit113"] ~ "TN109_113",
                                                  TRUE ~ "TN113"
                                                  ))
  

dataLog$classif <- factor(dataLog$classif, levels = list("TN087", "TN087_091", "TN091_093", "TN093_095", "TN095_105", "TN105_107", "TN107_109", "TN109_113", "TN113"))
dataLog_table <- as.data.frame(table(dataLog$classif, dataLog$Quantity, dnn = c("Classif", "Quantity")))
sum_total <- sum(dataLog_table$Freq)/3
dataLog_table$Perc <- round(100*(dataLog_table$Freq/sum_total), 2)
```



## Particionamiento de los datos

```{r}
set.seed(4)
mascara <- sample.split(dataLog$Quantity, SplitRatio = 7/10)
training_data <- dataLog[mascara,]
test_data <- dataLog[!mascara,]

```

```{r}
modelo <- randomForest(formula = Value ~ year + month + hour, data = training_data)

```




